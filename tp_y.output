Terminals unused in grammar

   DECL_LIST


Rules useless in parser due to conflicts

    5 declL: declL decl


State 4 conflicts: 1 shift/reduce
State 8 conflicts: 1 shift/reduce
State 9 conflicts: 1 shift/reduce, 2 reduce/reduce
State 10 conflicts: 1 shift/reduce
State 29 conflicts: 1 shift/reduce
State 30 conflicts: 1 shift/reduce
State 31 conflicts: 3 shift/reduce
State 34 conflicts: 4 shift/reduce
State 36 conflicts: 3 shift/reduce


Grammar

    0 $accept: programme $end

    1 programme: declL BEG expr END

    2 declL: decl
    3      | decl declL
    4      | declL declL
    5      | declL decl

    6 decl: ID ';'

    7 expr: IF bexpr THEN expr ELSE expr
    8     | IF bexpr THEN expr
    9     | expr ADD expr
   10     | expr SUB expr
   11     | expr AFFECT expr
   12     | CST
   13     | ID
   14     | '(' expr ')'

   15 bexpr: expr RELOP expr
   16      | '(' bexpr ')'


Terminals, with rules where they appear

$end (0) 0
'(' (40) 14 16
')' (41) 14 16
';' (59) 6
error (256)
IF (258) 7 8
THEN (259) 7 8
ELSE (260) 7
BEG (261) 1
END (262) 1
ADD (263) 9
SUB (264) 10
DECL_LIST (265)
AFFECT (266) 11
ID (267) 6 13
CST (268) 12
RELOP (269) 15


Nonterminals, with rules where they appear

$accept (18)
    on left: 0
programme (19)
    on left: 1, on right: 0
declL (20)
    on left: 2 3 4 5, on right: 1 3 4 5
decl (21)
    on left: 6, on right: 2 3 5
expr (22)
    on left: 7 8 9 10 11 12 13 14, on right: 1 7 8 9 10 11 14 15
bexpr (23)
    on left: 15 16, on right: 7 8 16


State 0

    0 $accept: . programme $end

    ID  shift, and go to state 1

    programme  go to state 2
    declL      go to state 3
    decl       go to state 4


State 1

    6 decl: ID . ';'

    ';'  shift, and go to state 5


State 2

    0 $accept: programme . $end

    $end  shift, and go to state 6


State 3

    1 programme: declL . BEG expr END
    4 declL: declL . declL
    5      | declL . decl

    BEG  shift, and go to state 7
    ID   shift, and go to state 1

    declL  go to state 8
    decl   go to state 9


State 4

    2 declL: decl .
    3      | decl . declL

    ID  shift, and go to state 1

    ID        [reduce using rule 2 (declL)]
    $default  reduce using rule 2 (declL)

    declL  go to state 10
    decl   go to state 4


State 5

    6 decl: ID ';' .

    $default  reduce using rule 6 (decl)


State 6

    0 $accept: programme $end .

    $default  accept


State 7

    1 programme: declL BEG . expr END

    IF   shift, and go to state 11
    ID   shift, and go to state 12
    CST  shift, and go to state 13
    '('  shift, and go to state 14

    expr  go to state 15


State 8

    4 declL: declL . declL
    4      | declL declL .
    5      | declL . decl

    ID  shift, and go to state 1

    ID        [reduce using rule 4 (declL)]
    $default  reduce using rule 4 (declL)

    declL  go to state 8
    decl   go to state 9


State 9

    2 declL: decl .
    3      | decl . declL
    5      | declL decl .

    ID  shift, and go to state 1

    BEG       reduce using rule 2 (declL)
    BEG       [reduce using rule 5 (declL)]
    ID        [reduce using rule 2 (declL)]
    ID        [reduce using rule 5 (declL)]
    $default  reduce using rule 2 (declL)

    declL  go to state 10
    decl   go to state 4


State 10

    3 declL: decl declL .
    4      | declL . declL
    5      | declL . decl

    ID  shift, and go to state 1

    ID        [reduce using rule 3 (declL)]
    $default  reduce using rule 3 (declL)

    declL  go to state 8
    decl   go to state 9


State 11

    7 expr: IF . bexpr THEN expr ELSE expr
    8     | IF . bexpr THEN expr

    IF   shift, and go to state 11
    ID   shift, and go to state 12
    CST  shift, and go to state 13
    '('  shift, and go to state 16

    expr   go to state 17
    bexpr  go to state 18


State 12

   13 expr: ID .

    $default  reduce using rule 13 (expr)


State 13

   12 expr: CST .

    $default  reduce using rule 12 (expr)


State 14

   14 expr: '(' . expr ')'

    IF   shift, and go to state 11
    ID   shift, and go to state 12
    CST  shift, and go to state 13
    '('  shift, and go to state 14

    expr  go to state 19


State 15

    1 programme: declL BEG expr . END
    9 expr: expr . ADD expr
   10     | expr . SUB expr
   11     | expr . AFFECT expr

    END     shift, and go to state 20
    ADD     shift, and go to state 21
    SUB     shift, and go to state 22
    AFFECT  shift, and go to state 23


State 16

   14 expr: '(' . expr ')'
   16 bexpr: '(' . bexpr ')'

    IF   shift, and go to state 11
    ID   shift, and go to state 12
    CST  shift, and go to state 13
    '('  shift, and go to state 16

    expr   go to state 24
    bexpr  go to state 25


State 17

    9 expr: expr . ADD expr
   10     | expr . SUB expr
   11     | expr . AFFECT expr
   15 bexpr: expr . RELOP expr

    ADD     shift, and go to state 21
    SUB     shift, and go to state 22
    AFFECT  shift, and go to state 23
    RELOP   shift, and go to state 26


State 18

    7 expr: IF bexpr . THEN expr ELSE expr
    8     | IF bexpr . THEN expr

    THEN  shift, and go to state 27


State 19

    9 expr: expr . ADD expr
   10     | expr . SUB expr
   11     | expr . AFFECT expr
   14     | '(' expr . ')'

    ADD     shift, and go to state 21
    SUB     shift, and go to state 22
    AFFECT  shift, and go to state 23
    ')'     shift, and go to state 28


State 20

    1 programme: declL BEG expr END .

    $default  reduce using rule 1 (programme)


State 21

    9 expr: expr ADD . expr

    IF   shift, and go to state 11
    ID   shift, and go to state 12
    CST  shift, and go to state 13
    '('  shift, and go to state 14

    expr  go to state 29


State 22

   10 expr: expr SUB . expr

    IF   shift, and go to state 11
    ID   shift, and go to state 12
    CST  shift, and go to state 13
    '('  shift, and go to state 14

    expr  go to state 30


State 23

   11 expr: expr AFFECT . expr

    IF   shift, and go to state 11
    ID   shift, and go to state 12
    CST  shift, and go to state 13
    '('  shift, and go to state 14

    expr  go to state 31


State 24

    9 expr: expr . ADD expr
   10     | expr . SUB expr
   11     | expr . AFFECT expr
   14     | '(' expr . ')'
   15 bexpr: expr . RELOP expr

    ADD     shift, and go to state 21
    SUB     shift, and go to state 22
    AFFECT  shift, and go to state 23
    RELOP   shift, and go to state 26
    ')'     shift, and go to state 28


State 25

   16 bexpr: '(' bexpr . ')'

    ')'  shift, and go to state 32


State 26

   15 bexpr: expr RELOP . expr

    IF   shift, and go to state 11
    ID   shift, and go to state 12
    CST  shift, and go to state 13
    '('  shift, and go to state 14

    expr  go to state 33


State 27

    7 expr: IF bexpr THEN . expr ELSE expr
    8     | IF bexpr THEN . expr

    IF   shift, and go to state 11
    ID   shift, and go to state 12
    CST  shift, and go to state 13
    '('  shift, and go to state 14

    expr  go to state 34


State 28

   14 expr: '(' expr ')' .

    $default  reduce using rule 14 (expr)


State 29

    9 expr: expr . ADD expr
    9     | expr ADD expr .
   10     | expr . SUB expr
   11     | expr . AFFECT expr

    AFFECT  shift, and go to state 23

    AFFECT    [reduce using rule 9 (expr)]
    $default  reduce using rule 9 (expr)


State 30

    9 expr: expr . ADD expr
   10     | expr . SUB expr
   10     | expr SUB expr .
   11     | expr . AFFECT expr

    AFFECT  shift, and go to state 23

    AFFECT    [reduce using rule 10 (expr)]
    $default  reduce using rule 10 (expr)


State 31

    9 expr: expr . ADD expr
   10     | expr . SUB expr
   11     | expr . AFFECT expr
   11     | expr AFFECT expr .

    ADD     shift, and go to state 21
    SUB     shift, and go to state 22
    AFFECT  shift, and go to state 23

    ADD       [reduce using rule 11 (expr)]
    SUB       [reduce using rule 11 (expr)]
    AFFECT    [reduce using rule 11 (expr)]
    $default  reduce using rule 11 (expr)


State 32

   16 bexpr: '(' bexpr ')' .

    $default  reduce using rule 16 (bexpr)


State 33

    9 expr: expr . ADD expr
   10     | expr . SUB expr
   11     | expr . AFFECT expr
   15 bexpr: expr RELOP expr .

    ADD     shift, and go to state 21
    SUB     shift, and go to state 22
    AFFECT  shift, and go to state 23

    $default  reduce using rule 15 (bexpr)


State 34

    7 expr: IF bexpr THEN expr . ELSE expr
    8     | IF bexpr THEN expr .
    9     | expr . ADD expr
   10     | expr . SUB expr
   11     | expr . AFFECT expr

    ELSE    shift, and go to state 35
    ADD     shift, and go to state 21
    SUB     shift, and go to state 22
    AFFECT  shift, and go to state 23

    ELSE      [reduce using rule 8 (expr)]
    ADD       [reduce using rule 8 (expr)]
    SUB       [reduce using rule 8 (expr)]
    AFFECT    [reduce using rule 8 (expr)]
    $default  reduce using rule 8 (expr)


State 35

    7 expr: IF bexpr THEN expr ELSE . expr

    IF   shift, and go to state 11
    ID   shift, and go to state 12
    CST  shift, and go to state 13
    '('  shift, and go to state 14

    expr  go to state 36


State 36

    7 expr: IF bexpr THEN expr ELSE expr .
    9     | expr . ADD expr
   10     | expr . SUB expr
   11     | expr . AFFECT expr

    ADD     shift, and go to state 21
    SUB     shift, and go to state 22
    AFFECT  shift, and go to state 23

    ADD       [reduce using rule 7 (expr)]
    SUB       [reduce using rule 7 (expr)]
    AFFECT    [reduce using rule 7 (expr)]
    $default  reduce using rule 7 (expr)
